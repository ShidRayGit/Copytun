#!/usr/bin/env bash
# copytun.sh - WaterWall Half-Duplex tunnel manager (menu-based)
# Thanks to Rad Kesvat for the WaterWall project
# https://github.com/radkesvat/WaterWall
# https://radkesvat.github.io/WaterWall-Docs/docs/intro

set -Eeuo pipefail

# -----------------------------
# Constants / paths
# -----------------------------
WW_VER="v1.41"
WW_BASE="/opt/waterwall"
WW_BIN="${WW_BASE}/bin/WaterWall"
WW_LIBS="${WW_BASE}/libs"

CT_BASE="/opt/copytun"

SYSTEMD_TEMPLATE="/etc/systemd/system/copytun@.service"

# -----------------------------
# TTY-safe input (MANDATORY)
# -----------------------------
tty_read() {
  # Usage: tty_read varname "Prompt: "
  local __var="$1"
  local __prompt="${2:-}"
  if [[ -n "$__prompt" ]]; then
    printf "%s" "$__prompt" > /dev/tty
  fi
  local __val=""
  IFS= read -r __val < /dev/tty
  printf -v "$__var" "%s" "$__val"
}

tty_pause() {
  printf "Press Enter to continue..." > /dev/tty
  local _x
  IFS= read -r _x < /dev/tty
}

tty_clear() {
  # Clear screen only if TTY exists
  if [[ -t 1 ]] && [[ -c /dev/tty ]]; then
    command -v clear >/dev/null 2>&1 && clear > /dev/tty 2>/dev/null || true
  fi
}

die() {
  printf "ERROR: %s\n" "${1:-Unknown error}" > /dev/tty
  exit 1
}

need_root() {
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    die "Please run as root (use sudo)."
  fi
}

# -----------------------------
# WaterWall docs-aligned JSON
# - Node structure: {name,type,settings,next}
# - TcpListener/TcpConnector settings use keys address/port (per examples) 0
# - HalfDuplexClient/HalfDuplexServer settings are {} and require next 1
# - core.json structure: log{path,core,network,dns}, misc{workers,ram-profile,libs-path}, configs[...] 2
# -----------------------------
write_core_json() {
  local tunnel_dir="$1"
  local tunnel_name="$2"
  local role="$3"              # iran | foreign
  local config_rel="$4"        # e.g. configs/iran-halfduplex.json

  mkdir -p "${tunnel_dir}/logs" "${tunnel_dir}/configs"

  # Create log files (viewer expects them)
  : > "${tunnel_dir}/logs/core.log" || true
  : > "${tunnel_dir}/logs/network.log" || true
  : > "${tunnel_dir}/logs/dns.log" || true
  : > "${tunnel_dir}/logs/internal.log" || true

  # WaterWall core config (we name it <TUNNEL_NAME>.json and symlink core.json -> it)
  cat > "${tunnel_dir}/${tunnel_name}.json" <<EOF
{
  "log": {
    "path": "logs/",
    "core": {
      "loglevel": "INFO",
      "file": "core.log",
      "console": false
    },
    "network": {
      "loglevel": "INFO",
      "file": "network.log",
      "console": false
    },
    "dns": {
      "loglevel": "INFO",
      "file": "dns.log",
      "console": false
    }
  },
  "misc": {
    "workers": 0,
    "ram-profile": "server",
    "libs-path": "${WW_LIBS}/"
  },
  "configs": ["${config_rel}"]
}
EOF

  ln -sfn "${tunnel_dir}/${tunnel_name}.json" "${tunnel_dir}/core.json"
}

write_iran_config() {
  local tunnel_dir="$1"
  local tunnel_name="$2"
  local local_port="$3"
  local foreign_ip="$4"
  local tunnel_port="$5"

  cat > "${tunnel_dir}/configs/iran-halfduplex.json" <<EOF
{
  "name": "${tunnel_name}-iran-halfduplex",
  "nodes": [
    {
      "name": "listener",
      "type": "TcpListener",
      "settings": {
        "address": "0.0.0.0",
        "port": ${local_port}
      },
      "next": "halfduplex_client"
    },
    {
      "name": "halfduplex_client",
      "type": "HalfDuplexClient",
      "settings": {},
      "next": "connector"
    },
    {
      "name": "connector",
      "type": "TcpConnector",
      "settings": {
        "address": "${foreign_ip}",
        "port": ${tunnel_port}
      }
    }
  ]
}
EOF
}

write_foreign_config() {
  local tunnel_dir="$1"
  local tunnel_name="$2"
  local tunnel_port="$3"
  local target_port="$4"

  cat > "${tunnel_dir}/configs/foreign-halfduplex.json" <<EOF
{
  "name": "${tunnel_name}-foreign-halfduplex",
  "nodes": [
    {
      "name": "listener",
      "type": "TcpListener",
      "settings": {
        "address": "0.0.0.0",
        "port": ${tunnel_port}
      },
      "next": "halfduplex_server"
    },
    {
      "name": "halfduplex_server",
      "type": "HalfDuplexServer",
      "settings": {},
      "next": "connector"
    },
    {
      "name": "connector",
      "type": "TcpConnector",
      "settings": {
        "address": "127.0.0.1",
        "port": ${target_port}
      }
    }
  ]
}
EOF
}

write_meta_env() {
  local tunnel_dir="$1"
  shift
  # remaining args are KEY=VALUE
  : > "${tunnel_dir}/meta.env"
  for kv in "$@"; do
    printf "%s\n" "$kv" >> "${tunnel_dir}/meta.env"
  done
}

load_meta_env() {
  local tunnel_dir="$1"
  # shellcheck disable=SC1090
  if [[ -f "${tunnel_dir}/meta.env" ]]; then
    set -a
    # meta.env is generated by this script (key=value, no spaces). Still, guard with 'source'.
    source "${tunnel_dir}/meta.env"
    set +a
  else
    return 1
  fi
}

# -----------------------------
# systemd template
# -----------------------------
ensure_systemd_template() {
  if [[ -f "${SYSTEMD_TEMPLATE}" ]]; then
    return 0
  fi

  cat > "${SYSTEMD_TEMPLATE}" <<'EOF'
[Unit]
Description=copytun WaterWall Tunnel (%i)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
WorkingDirectory=/opt/copytun/%i
ExecStart=/opt/waterwall/bin/WaterWall
Restart=always
RestartSec=2
LimitNOFILE=1048576

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload >/dev/null 2>&1 || true
}

svc_name() {
  local tn="$1"
  printf "copytun@%s.service" "$tn"
}

svc_enable_start() {
  local tn="$1"
  ensure_systemd_template
  systemctl daemon-reload >/dev/null 2>&1 || true
  systemctl enable --now "$(svc_name "$tn")" >/dev/null 2>&1 || true
}

svc_restart() {
  local tn="$1"
  ensure_systemd_template
  systemctl daemon-reload >/dev/null 2>&1 || true
  systemctl restart "$(svc_name "$tn")" >/dev/null 2>&1 || true
}

svc_stop_disable() {
  local tn="$1"
  systemctl stop "$(svc_name "$tn")" >/dev/null 2>&1 || true
  systemctl disable "$(svc_name "$tn")" >/dev/null 2>&1 || true
  systemctl daemon-reload >/dev/null 2>&1 || true
}

svc_is_active() {
  local tn="$1"
  systemctl is-active --quiet "$(svc_name "$tn")"
}

# -----------------------------
# WaterWall installer (v1.41)
# Assets (linux) appear in release list 3
# -----------------------------
detect_arch() {
  local a
  a="$(uname -m 2>/dev/null || echo unknown)"
  case "$a" in
    x86_64|amd64) echo "x86_64" ;;
    aarch64|arm64) echo "arm64" ;;
    *) echo "unknown" ;;
  esac
}

ensure_deps() {
  # best-effort install via available package manager; otherwise rely on existing tools
  local need=()
  command -v wget >/dev/null 2>&1 || need+=("wget")
  command -v unzip >/dev/null 2>&1 || need+=("unzip")

  if [[ "${#need[@]}" -eq 0 ]]; then
    return 0
  fi

  # Try common managers
  if command -v apt-get >/dev/null 2>&1; then
    apt-get update -y >/dev/null 2>&1 || true
    apt-get install -y "${need[@]}" >/dev/null 2>&1 || true
  elif command -v dnf >/dev/null 2>&1; then
    dnf install -y "${need[@]}" >/dev/null 2>&1 || true
  elif command -v yum >/dev/null 2>&1; then
    yum install -y "${need[@]}" >/dev/null 2>&1 || true
  elif command -v pacman >/dev/null 2>&1; then
    pacman -Sy --noconfirm "${need[@]}" >/dev/null 2>&1 || true
  elif command -v apk >/dev/null 2>&1; then
    apk add --no-cache "${need[@]}" >/dev/null 2>&1 || true
  fi
}

select_ww_asset() {
  local arch="$1"
  local choice=""
  tty_clear
  printf "WaterWall (%s) is not installed. Let's install %s.\n\n" "$WW_BIN" "$WW_VER" > /dev/tty

  if [[ "$arch" == "x86_64" ]]; then
    printf "Select your Linux x86_64 build:\n" > /dev/tty
    printf "1) gcc x64\n" > /dev/tty
    printf "2) gcc x64 old-cpu (avoid Illegal instruction)\n" > /dev/tty
    printf "3) clang x64\n" > /dev/tty
    printf "4) clang avx512 (very new CPUs only)\n" > /dev/tty
    tty_read choice "Enter choice [1-4]: "
    case "$choice" in
      1) echo "Waterwall-linux-gcc-x64.zip" ;;
      2) echo "Waterwall-linux-gcc-x64-old-cpu.zip" ;;
      3) echo "Waterwall-linux-clang-x64.zip" ;;
      4) echo "Waterwall-linux-clang-avx512f-x64.zip" ;;
      *) die "Invalid choice." ;;
    esac
  elif [[ "$arch" == "arm64" ]]; then
    printf "Select your Linux arm64 build:\n" > /dev/tty
    printf "1) gcc arm64\n" > /dev/tty
    printf "2) gcc arm64 old-cpu\n" > /dev/tty
    tty_read choice "Enter choice [1-2]: "
    case "$choice" in
      1) echo "Waterwall-linux-gcc-arm64.zip" ;;
      2) echo "Waterwall-linux-gcc-arm64-old-cpu.zip" ;;
      *) die "Invalid choice." ;;
    esac
  else
    die "Unsupported architecture: $(uname -m)."
  fi
}

install_waterwall() {
  if [[ -x "$WW_BIN" ]]; then
    return 0
  fi

  ensure_deps

  local arch asset url tmpd
  arch="$(detect_arch)"
  asset="$(select_ww_asset "$arch")"
  url="https://github.com/radkesvat/WaterWall/releases/download/${WW_VER}/${asset}"

  tmpd="$(mktemp -d)"
  mkdir -p "${WW_BASE}/bin" "${WW_BASE}/libs"

  printf "\nDownloading: %s\n" "$url" > /dev/tty
  wget -qO "${tmpd}/ww.zip" "$url" || die "Failed to download WaterWall asset."

  unzip -q "${tmpd}/ww.zip" -d "${tmpd}/ww" || die "Failed to unzip WaterWall asset."

  # The release zips include WaterWall binary and libs directory (per docs style).
  # Best-effort locate binary and libs.
  local found_bin=""
  found_bin="$(find "${tmpd}/ww" -maxdepth 3 -type f -name 'WaterWall' 2>/dev/null | head -n 1 || true)"
  [[ -n "$found_bin" ]] || die "Could not find WaterWall binary inside the zip."

  # Copy binary
  install -m 0755 "$found_bin" "${WW_BIN}"

  # Copy libs (if present)
  local found_libs=""
  found_libs="$(find "${tmpd}/ww" -maxdepth 3 -type d -name 'libs' 2>/dev/null | head -n 1 || true)"
  if [[ -n "$found_libs" ]]; then
    rm -rf "${WW_LIBS}" || true
    mkdir -p "${WW_LIBS}"
    cp -a "${found_libs}/." "${WW_LIBS}/"
  fi

  rm -rf "$tmpd" || true

  if [[ ! -x "$WW_BIN" ]]; then
    die "WaterWall installation failed (binary not executable)."
  fi

  printf "WaterWall installed at: %s\n" "$WW_BIN" > /dev/tty
  tty_pause
}

# -----------------------------
# Validation helpers
# -----------------------------
valid_name() {
  local n="$1"
  [[ "$n" =~ ^[A-Za-z0-9_-]+$ ]]
}

valid_port() {
  local p="$1"
  [[ "$p" =~ ^[0-9]+$ ]] && (( p >= 1 && p <= 65535 ))
}

# -----------------------------
# Tunnel create / edit
# -----------------------------
create_tunnel() {
  install_waterwall
  ensure_systemd_template

  mkdir -p "${CT_BASE}"

  tty_clear
  local tn
  tty_read tn "Enter tunnel name (A-Z a-z 0-9 _ -): "
  valid_name "$tn" || die "Invalid tunnel name."
  local tdir="${CT_BASE}/${tn}"
  if [[ -d "$tdir" ]]; then
    die "Tunnel already exists: ${tn}"
  fi

  local role_choice
  printf "\nSelect role:\n" > /dev/tty
  printf "1) Iran server (Client / HalfDuplexClient)\n" > /dev/tty
  printf "2) Foreign server (Server / HalfDuplexServer)\n" > /dev/tty
  tty_read role_choice "Enter choice [1-2]: "

  mkdir -p "$tdir/configs" "$tdir/logs"

  if [[ "$role_choice" == "1" ]]; then
    # Iran server (client)
    local local_port tunnel_port foreign_ip
    tty_read local_port "Local listen port (users connect here, e.g. 5055): "
    valid_port "$local_port" || die "Invalid port."

    tty_read tunnel_port "Tunnel port (connects to foreign server, e.g. 449): "
    valid_port "$tunnel_port" || die "Invalid port."

    tty_read foreign_ip "Foreign server IP (or hostname): "
    [[ -n "$foreign_ip" ]] || die "Foreign IP/host cannot be empty."

    write_iran_config "$tdir" "$tn" "$local_port" "$foreign_ip" "$tunnel_port"
    write_foreign_config "$tdir" "$tn" "$tunnel_port" "$local_port"  # kept for reference; not used unless role changed manually
    write_core_json "$tdir" "$tn" "iran" "configs/iran-halfduplex.json"
    write_meta_env "$tdir" \
      "TUNNEL_NAME=${tn}" \
      "ROLE=iran" \
      "IRAN_LOCAL_PORT=${local_port}" \
      "IRAN_TUNNEL_PORT=${tunnel_port}" \
      "IRAN_FOREIGN_IP=${foreign_ip}"

  elif [[ "$role_choice" == "2" ]]; then
    # Foreign server (server)
    local target_port tunnel_port
    tty_read target_port "Target service port (e.g. Xray inbound, e.g. 5055): "
    valid_port "$target_port" || die "Invalid port."

    tty_read tunnel_port "Tunnel listen port (e.g. 449): "
    valid_port "$tunnel_port" || die "Invalid port."

    write_foreign_config "$tdir" "$tn" "$tunnel_port" "$target_port"
    write_iran_config "$tdir" "$tn" "$target_port" "CHANGE_ME" "$tunnel_port" # kept for reference; not used unless role changed manually
    write_core_json "$tdir" "$tn" "foreign" "configs/foreign-halfduplex.json"
    write_meta_env "$tdir" \
      "TUNNEL_NAME=${tn}" \
      "ROLE=foreign" \
      "FOREIGN_TARGET_PORT=${target_port}" \
      "FOREIGN_TUNNEL_PORT=${tunnel_port}"
  else
    rm -rf "$tdir" || true
    die "Invalid choice."
  fi

  svc_enable_start "$tn"

  printf "\nTunnel created: %s\n" "$tn" > /dev/tty
  printf "Service: %s\n" "$(svc_name "$tn")" > /dev/tty
  tty_pause
}

regenerate_from_meta() {
  local tn="$1"
  local tdir="${CT_BASE}/${tn}"
  [[ -d "$tdir" ]] || die "Tunnel dir not found."

  load_meta_env "$tdir" || die "meta.env missing."

  mkdir -p "$tdir/configs" "$tdir/logs"

  if [[ "${ROLE:-}" == "iran" ]]; then
    valid_port "${IRAN_LOCAL_PORT:-}" || die "Invalid meta: IRAN_LOCAL_PORT"
    valid_port "${IRAN_TUNNEL_PORT:-}" || die "Invalid meta: IRAN_TUNNEL_PORT"
    [[ -n "${IRAN_FOREIGN_IP:-}" ]] || die "Invalid meta: IRAN_FOREIGN_IP"

    write_iran_config "$tdir" "$tn" "$IRAN_LOCAL_PORT" "$IRAN_FOREIGN_IP" "$IRAN_TUNNEL_PORT"
    write_foreign_config "$tdir" "$tn" "$IRAN_TUNNEL_PORT" "$IRAN_LOCAL_PORT"
    write_core_json "$tdir" "$tn" "iran" "configs/iran-halfduplex.json"

  elif [[ "${ROLE:-}" == "foreign" ]]; then
    valid_port "${FOREIGN_TARGET_PORT:-}" || die "Invalid meta: FOREIGN_TARGET_PORT"
    valid_port "${FOREIGN_TUNNEL_PORT:-}" || die "Invalid meta: FOREIGN_TUNNEL_PORT"

    write_foreign_config "$tdir" "$tn" "$FOREIGN_TUNNEL_PORT" "$FOREIGN_TARGET_PORT"
    write_iran_config "$tdir" "$tn" "$FOREIGN_TARGET_PORT" "CHANGE_ME" "$FOREIGN_TUNNEL_PORT"
    write_core_json "$tdir" "$tn" "foreign" "configs/foreign-halfduplex.json"
  else
    die "Unknown ROLE in meta.env (expected iran or foreign)."
  fi
}

edit_tunnel() {
  local tn="$1"
  local tdir="${CT_BASE}/${tn}"
  load_meta_env "$tdir" || die "meta.env missing."

  tty_clear
  printf "Editing tunnel: %s\nRole: %s\n\n" "$tn" "$ROLE" > /dev/tty

  if [[ "$ROLE" == "iran" ]]; then
    printf "1) Edit Foreign IP (current: %s)\n" "${IRAN_FOREIGN_IP:-}" > /dev/tty
    printf "2) Edit Local listen port (current: %s)\n" "${IRAN_LOCAL_PORT:-}" > /dev/tty
    printf "3) Edit Tunnel port (current: %s)\n" "${IRAN_TUNNEL_PORT:-}" > /dev/tty
    printf "0) Back\n" > /dev/tty
    local c v
    tty_read c "Choose: "
    case "$c" in
      1) tty_read v "New Foreign IP/host: "; [[ -n "$v" ]] || die "Empty."; IRAN_FOREIGN_IP="$v" ;;
      2) tty_read v "New Local listen port: "; valid_port "$v" || die "Invalid port."; IRAN_LOCAL_PORT="$v" ;;
      3) tty_read v "New Tunnel port: "; valid_port "$v" || die "Invalid port."; IRAN_TUNNEL_PORT="$v" ;;
      0) return 0 ;;
      *) die "Invalid choice." ;;
    esac

    write_meta_env "$tdir" \
      "TUNNEL_NAME=${tn}" \
      "ROLE=iran" \
      "IRAN_LOCAL_PORT=${IRAN_LOCAL_PORT}" \
      "IRAN_TUNNEL_PORT=${IRAN_TUNNEL_PORT}" \
      "IRAN_FOREIGN_IP=${IRAN_FOREIGN_IP}"

  elif [[ "$ROLE" == "foreign" ]]; then
    printf "1) Edit Target service port (current: %s)\n" "${FOREIGN_TARGET_PORT:-}" > /dev/tty
    printf "2) Edit Tunnel listen port (current: %s)\n" "${FOREIGN_TUNNEL_PORT:-}" > /dev/tty
    printf "0) Back\n" > /dev/tty
    local c v
    tty_read c "Choose: "
    case "$c" in
      1) tty_read v "New Target service port: "; valid_port "$v" || die "Invalid port."; FOREIGN_TARGET_PORT="$v" ;;
      2) tty_read v "New Tunnel listen port: "; valid_port "$v" || die "Invalid port."; FOREIGN_TUNNEL_PORT="$v" ;;
      0) return 0 ;;
      *) die "Invalid choice." ;;
    esac

    write_meta_env "$tdir" \
      "TUNNEL_NAME=${tn}" \
      "ROLE=foreign" \
      "FOREIGN_TARGET_PORT=${FOREIGN_TARGET_PORT}" \
      "FOREIGN_TUNNEL_PORT=${FOREIGN_TUNNEL_PORT}"
  else
    die "Unknown ROLE in meta.env."
  fi

  regenerate_from_meta "$tn"
  svc_restart "$tn"

  printf "\nUpdated and restarted: %s\n" "$(svc_name "$tn")" > /dev/tty
  tty_pause
}

delete_tunnel() {
  local tn="$1"
  local tdir="${CT_BASE}/${tn}"
  [[ -d "$tdir" ]] || die "Tunnel not found."

  tty_clear
  printf "Delete tunnel '%s'?\nType YES to confirm: " "$tn" > /dev/tty
  local ans
  IFS= read -r ans < /dev/tty
  if [[ "$ans" != "YES" ]]; then
    printf "Cancelled.\n" > /dev/tty
    tty_pause
    return 0
  fi

  svc_stop_disable "$tn"
  rm -rf "$tdir" || true

  printf "Deleted tunnel: %s\n" "$tn" > /dev/tty
  tty_pause
}

# -----------------------------
# List / manage tunnels
# -----------------------------
list_tunnels() {
  mkdir -p "${CT_BASE}"
  local dirs=()
  local d
  while IFS= read -r -d '' d; do
    dirs+=("$d")
  done < <(find "${CT_BASE}" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null || true)

  if [[ "${#dirs[@]}" -eq 0 ]]; then
    tty_clear
    printf "No tunnels found.\n" > /dev/tty
    tty_pause
    return 0
  fi

  tty_clear
  printf "Tunnels:\n" > /dev/tty
  printf "---------------------------------------------\n" > /dev/tty

  local i=0
  local names=()
  for d in "${dirs[@]}"; do
    i=$((i+1))
    local tn
    tn="$(basename "$d")"
    names+=("$tn")

    local role="unknown" summary="(no meta.env)"
    if load_meta_env "$d" 2>/dev/null; then
      role="${ROLE:-unknown}"
      if [[ "$role" == "iran" ]]; then
        summary="local:${IRAN_LOCAL_PORT:-?} -> ${IRAN_FOREIGN_IP:-?}:${IRAN_TUNNEL_PORT:-?}"
      elif [[ "$role" == "foreign" ]]; then
        summary="0.0.0.0:${FOREIGN_TUNNEL_PORT:-?} -> 127.0.0.1:${FOREIGN_TARGET_PORT:-?}"
      fi
    fi

    local st="inactive"
    if svc_is_active "$tn"; then st="active"; fi

    printf "%2d) %-20s role:%-7s  %-35s  [%s]\n" "$i" "$tn" "$role" "$summary" "$st" > /dev/tty
  done

  printf "---------------------------------------------\n" > /dev/tty
  printf "Select a tunnel by number (or 0 to back)\n" > /dev/tty
  local choice
  tty_read choice "Enter: "
  if [[ "$choice" == "0" ]]; then
    return 0
  fi
  [[ "$choice" =~ ^[0-9]+$ ]] || die "Invalid selection."
  (( choice >= 1 && choice <= ${#names[@]} )) || die "Out of range."

  manage_tunnel "${names[$((choice-1))]}"
}

view_log_files() {
  local tn="$1"
  local tdir="${CT_BASE}/${tn}"
  local ldir="${tdir}/logs"
  [[ -d "$ldir" ]] || die "Logs directory not found."

  local files=()
  local f
  for f in core.log network.log dns.log internal.log; do
    if [[ -f "${ldir}/${f}" ]]; then
      files+=("${f}")
    fi
  done

  tty_clear
  if [[ "${#files[@]}" -eq 0 ]]; then
    printf "No log files found in %s\n" "$ldir" > /dev/tty
    tty_pause
    return 0
  fi

  printf "Log files for %s:\n" "$tn" > /dev/tty
  local i=0
  for f in "${files[@]}"; do
    i=$((i+1))
    printf "%d) %s\n" "$i" "$f" > /dev/tty
  done
  printf "0) Back\n" > /dev/tty

  local c
  tty_read c "Choose file: "
  if [[ "$c" == "0" ]]; then
    return 0
  fi
  [[ "$c" =~ ^[0-9]+$ ]] || die "Invalid selection."
  (( c >= 1 && c <= ${#files[@]} )) || die "Out of range."
  local selected="${files[$((c-1))]}"

  tty_clear
  printf "1) tail -n 200\n" > /dev/tty
  printf "2) tail -f (live)\n" > /dev/tty
  printf "0) Back\n" > /dev/tty
  local mode
  tty_read mode "Choose: "
  case "$mode" in
    1)
      tail -n 200 "${ldir}/${selected}" | sed 's/\r$//' > /dev/tty
      printf "\n" > /dev/tty
      tty_pause
      ;;
    2)
      printf "Live mode. Press Ctrl+C to stop.\n\n" > /dev/tty
      # tail -f writes to stdout; redirect to tty for safety
      tail -f "${ldir}/${selected}" > /dev/tty
      ;;
    0) return 0 ;;
    *) die "Invalid choice." ;;
  esac
}

manage_tunnel() {
  local tn="$1"
  local sname
  sname="$(svc_name "$tn")"

  while true; do
    tty_clear
    local st="inactive"
    if svc_is_active "$tn"; then st="active"; fi
    printf "Manage tunnel: %s  [%s]\n" "$tn" "$st" > /dev/tty
    printf "--------------------------------\n" > /dev/tty
    printf "1) Start / Restart\n" > /dev/tty
    printf "2) Stop\n" > /dev/tty
    printf "3) Service status (systemctl status)\n" > /dev/tty
    printf "4) Service logs (journalctl -u)\n" > /dev/tty
    printf "5) View log files\n" > /dev/tty
    printf "6) Edit tunnel\n" > /dev/tty
    printf "7) Delete tunnel\n" > /dev/tty
    printf "0) Back\n" > /dev/tty

    local c
    tty_read c "Choose: "
    case "$c" in
      1) svc_enable_start "$tn"; svc_restart "$tn"; printf "Restarted.\n" > /dev/tty; tty_pause ;;
      2) systemctl stop "$sname" >/dev/null 2>&1 || true; printf "Stopped.\n" > /dev/tty; tty_pause ;;
      3) systemctl status "$sname" --no-pager > /dev/tty 2>&1 || true; tty_pause ;;
      4) journalctl -u "$sname" --no-pager -n 200 > /dev/tty 2>&1 || true; tty_pause ;;
      5) view_log_files "$tn" ;;
      6) edit_tunnel "$tn" ;;
      7) delete_tunnel "$tn"; return 0 ;;
      0) return 0 ;;
      *) printf "Invalid choice.\n" > /dev/tty; tty_pause ;;
    esac
  done
}

# -----------------------------
# Main menu
# -----------------------------
main_menu() {
  need_root
  mkdir -p "${CT_BASE}"
  ensure_systemd_template

  while true; do
    tty_clear
    printf "copytun - WaterWall Half-Duplex tunnel manager\n" > /dev/tty
    printf "---------------------------------------------\n" > /dev/tty
    printf "1) Create tunnel\n" > /dev/tty
    printf "2) List / Manage tunnels\n" > /dev/tty
    printf "3) Exit\n" > /dev/tty
    local c
    tty_read c "Choose: "
    case "$c" in
      1) create_tunnel ;;
      2) list_tunnels ;;
      3) tty_clear; exit 0 ;;
      *) printf "Invalid choice.\n" > /dev/tty; tty_pause ;;
    esac
  done
}

main_menu
```4